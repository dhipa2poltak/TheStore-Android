apply plugin: 'jacoco'

jacoco {
    toolVersion '0.8.11'
}

tasks.withType(Test).configureEach {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

project.afterEvaluate {
    def variants = ["debug", "prodDebug"]

    tasks.create(name: "allDebugCoverage", type: JacocoReport) {
        group = "Reporting"
        description = "Generate overall Jacoco coverage report for the debug build."

        reports {
            html.required.set(true)
            xml.required.set(true)
        }

        def excludes = [
            // data binding
            'android/databinding/**/*.class',
            '**/android/databinding/*Binding.class',
            '**/android/databinding/*',
            '**/androidx/databinding/*',
            '**/databinding/*',
            '**/BR.*',
            '**/DataBinding*.*',
            // android
            '**/R.class',
            '**/R$*.class',
            '**/BuildConfig.*',
            '**/Manifest*.*',
            '**/*Test*.*',
            'android/**/*.*',
            // dagger
            '**/*_MembersInjector.class',
            '**/Dagger*Component.class',
            '**/Dagger*Component$Builder.class',
            '**/Dagger*Subcomponent*.class',
            '**/*Subcomponent$Builder.class',
            '**/*Module_*Factory.class',
            '**/di/module/*',
            '**/*_Factory*.*',
            '**/*Module*.*',
            '**/*Dagger*.*',
            '**/*Hilt*.*',
            'hilt*',
            'dagger*',
            // kotlin
            '**/*MapperImpl*.*',
            '**/*$ViewInjector*.*',
            '**/*$ViewBinder*.*',
            '**/BuildConfig.*',
            '**/*Component*.*',
            '**/*BR*.*',
            '**/Manifest*.*',
            '**/*$Lambda$*.*',
            '**/*Companion*.*',
            '**/*Module*.*',
            '**/*Dagger*.*',
            '**/*Hilt*.*',
            '**/*MembersInjector*.*',
            '**/*_MembersInjector.class',
            '**/*_Factory*.*',
            '**/*_Provide*Factory*.*',
            '**/*Extensions*.*',
            // sealed and data classes
            '**/*$Result.*',
            '**/*$Result$*.*',
            // adapters generated by moshi
            '**/*JsonAdapter.*',
            '**/*Fragment.*',
            '**/*Fragment*.*',
            '**/*Activity.*',
            '**/*Activity*.*',
            '**/*Adapter.*',
            '**/*Adapter*.*',
            '**/TheApplication*.*',
            '**/framework/Config.*',
            '**/DefaultOnlineChecker*.*'
        ]

        def jClasses = subprojects.collect { proj ->
            variants.collect { variant ->
                "${proj.buildDir}/intermediates/javac/$variant/classes"
            }
        }.flatten()

        def kClasses = subprojects.collect { proj ->
            variants.collect { variant ->
                "${proj.buildDir}/tmp/kotlin-classes/$variant"
            }
        }.flatten()

        def kClassesLib = subprojects.collect { proj ->
            "${proj.buildDir}/classes/kotlin/main"
        }.flatten()

        def javaClasses = jClasses.collect { path ->
            fileTree(dir: path, excludes: excludes)
        }

        def kotlinClasses = kClasses.collect { path ->
            fileTree(dir: path, excludes: excludes)
        }

        def kotlinClassesLib = kClassesLib.collect { path ->
            fileTree(dir: path, excludes: excludes)
        }

        classDirectories.from = files([javaClasses, kotlinClasses, kotlinClassesLib])

        def sources = subprojects.collect { proj ->
            variants.collect { variant ->
                [
                    "${proj.projectDir}/src/main/java",
                    "${proj.projectDir}/src/main/kotlin",
                    "${proj.projectDir}/src/$variant/java",
                    "${proj.projectDir}/src/$variant/kotlin"
                ]
            }.flatten()
        }.flatten()

        sourceDirectories.from = files(sources)

        def executions = subprojects.collect { proj ->
            variants.collect { variant ->
                def path = "${proj.buildDir}/jacoco/test${variant.capitalize()}UnitTest.exec"
                if ((new File(path)).exists())
                    path
                else {
                    path = "${proj.buildDir}/jacoco/test.exec"
                    if ((new File(path)).exists()) path else null
                }
            }
        }.flatten()

        executions.removeAll([null])
        executionData.from = files(executions)
    }
}
